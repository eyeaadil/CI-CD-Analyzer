// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [pgvector(map: "vector")]
}

// 1. User Model
// Stores user information, authenticated via GitHub.
model User {
  id        Int      @id @default(autoincrement())
  githubId  String   @unique
  username  String
  avatarUrl String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  repos Repo[]
}

// 2. Repo Model
// Stores information about repositories onboarded by users.
model Repo {
  id        Int      @id @default(autoincrement())
  name      String
  githubId  String   @unique
  owner     String
  isPrivate Boolean
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId Int
  user   User @relation(fields: [userId], references: [id])

  runs WorkflowRun[]

  @@index([userId])
}

// Phase 1: Smart Log Chunking
model LogChunk {
  id              Int       @id @default(autoincrement())
  workflowRunId   Int
  chunkIndex      Int       // Order of chunks (0-based)
  stepName        String?   // e.g., "Setup", "Build", "Test"
  content         String    @db.Text
  startLine       Int       // Starting line number in original log
  endLine         Int       // Ending line number in original log
  tokenCount      Int?      // Approximate token count
  hasErrors       Boolean   @default(false)
  errorCount      Int       @default(0)
  
  // Phase 2: Embeddings for semantic search
  embedding       Unsupported("vector(768)")?  // 768-dim vector from Gemini
  
  createdAt       DateTime  @default(now())
  
  workflowRun     WorkflowRun @relation(fields: [workflowRunId], references: [id], onDelete: Cascade)
  
  @@unique([workflowRunId, chunkIndex])
  @@index([workflowRunId])
  @@index([stepName])
  @@index([hasErrors])
}


// 3. WorkflowRun Model
// Stores information about a specific CI/CD workflow run.
model WorkflowRun {
  id            Int      @id @default(autoincrement())
  githubRunId   String   @unique
  workflowName  String
  status        String   // e.g., 'success', 'failure', 'in_progress'
  triggerEvent  String
  commitSha     String
  branch        String
  actor         String
  runUrl        String
  rawLogUrl     String?  // URL to the stored raw log file (e.g., in S3)
  createdAt     DateTime @default(now())

  repoId Int
  repo   Repo @relation(fields: [repoId], references: [id])
  
  analysis AnalysisResult? @relation("WorkflowRunAnalysis")
  chunks   LogChunk[]      // Phase 1: Smart log chunking

  @@index([repoId])
}

// 4. AnalysisResult Model
// Stores the output of the AI log analysis.
model AnalysisResult {
  id            Int      @id @default(autoincrement())
  
  rootCause     String
  failureStage  String
  suggestedFix  String
  
  detectedErrors Json?   // Storing DetectedError[] as JSON
  steps          Json?   // Storing LogStep[] as JSON for detailed view
  
  createdAt     DateTime @default(now())
  
  workflowRunId Int @unique
  workflowRun   WorkflowRun @relation("WorkflowRunAnalysis", fields: [workflowRunId], references: [id])
}
